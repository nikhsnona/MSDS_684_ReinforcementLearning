# **Lab 5 – Semi-Gradient SARSA with Tile Coding (MountainCar-v0)**

This lab contains the complete implementation for MSDS 684 – Reinforcement Learning, Lab 5.
The focus of this lab is transitioning from tabular reinforcement learning to function approximation, using tile coding and semi-gradient SARSA to solve the continuous-state MountainCar-v0 environment.

All experiments are implemented in a Jupyter notebook, with clear modular sections for the tile coder, SARSA agent, experiments, visualizations, and extra analysis.



## **Project Contents**

This lab includes a full pipeline for solving MountainCar using linear function approximation:

* Custom TileCoder implementation in NumPy
* Semi-gradient SARSA agent with linear Q approximation
* ε-greedy exploration with decay
* Value function computation using `max_a Q(s,a)`
* Evaluation across a 2D grid of position × velocity
* Policy visualization and greedy trajectory rollouts
* Convergence comparison across feature configurations:

  * 4 tilings × 4×4 tiles
  * 8 tilings × 8×8 tiles (baseline)
  * 16 tilings × 8×8 tiles
* **Extra experiments**:

  * Epsilon schedule comparison (0.99 vs 0.995 vs 0.999)
  * Learning rate (α) comparison (0.05, 0.10, 0.20)

All results are automatically saved to the `lab5_outputs/` directory, including figures and raw numeric data (CSV/NPZ).



## **How to Use This Code**

1. Clone or download this repository.

2. Install dependencies using the included `requirements.txt`.

3. Run:

   ```bash
   python lab5_mountaincar_sarsa_tilecoding.py
   ```

4. To run **additional experiments**, execute the separate extra-experiments script or the extra block included in the repository.

5. Generated plots will appear in:

   ```
   lab5_outputs/
   lab5_outputs/data/
   ```

6. Adjust hyperparameters (tilings, tile sizes, alpha, epsilon decay) directly in the script to explore different behaviors.

The project is structured so reviewers can reproduce all primary results and explore extended experiments easily.



## **Dependencies**

Install required packages:

```
numpy
matplotlib
gymnasium[classic-control]
```

These ensure correct execution of tile coding, semi-gradient updates, Gymnasium environment handling, and visualizations.

You can install everything with:

```bash
pip install -r requirements.txt
```



## **Reproducibility**

* Each experiment uses fixed seeds internally through NumPy and Gymnasium.
* All main plots (learning curve, value heatmap, policy map, trajectories, convergence curves) can be regenerated by running the script.
* Extra experiments (epsilon decay and learning-rate comparisons) are separated for clean workflows but use the same structural code.
* All numeric outputs (CSV/NPZ) are saved automatically to allow further analysis and verification.



## **Repository Structure**

```
Lab5/
│── lab5.py     # Main implementation + plots and Epsilon + alpha experiments
│── requirements.txt
│── README.md
│
│── lab5_outputs/                             # Generated figures
│     │── learning_curve_steps_per_episode.png
│     │── value_function_heatmap.png
│     │── policy_map.png
│     │── trajectories_over_value.png
│     │── convergence_feature_configs.png
│     │── epsilon_schedules_convergence.png
│     │── alpha_schedules_convergence.png
│
└── lab5_outputs/data/                        # Numeric outputs
      │── learning_curve_steps_per_episode.csv
      │── value_function_grid.npz
      │── policy_grid.npy
      │── trajectories_over_value.npz
      │── convergence_feature_configs.csv
      │── epsilon_schedules_convergence.csv
      │── alpha_schedules_convergence.csv
```


